#!/usr/bin/env bash
set -euo pipefail

# Check core packages for available major version updates.
# Writes markdown report to /tmp/dependency-check.md and posts as PR comment.
#
# Requires: npm, node, GITHUB_TOKEN, PR_NUMBER (optional for comment)
# Sources: parse-dependency-policy.sh

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# shellcheck source=parse-dependency-policy.sh
source "$SCRIPT_DIR/parse-dependency-policy.sh"

# --- Check if we have core packages to monitor ---
if [ -z "$POLICY_CORE_PACKAGES" ]; then
  echo "::notice::No core packages configured, skipping dependency check"
  cat > /tmp/dependency-check.md << 'EOF'
## ðŸ“¦ Dependency Check

No core packages configured. Add a `.dependency-policy.yml` or set the `core-packages` input.

---
*Generated by [semantic-release-action](https://github.com/Rajlus/semantic-release-action)*
EOF
  echo "status=pass" >> "$GITHUB_OUTPUT"
  exit 0
fi

# --- Run npm outdated ---
echo "::group::Running npm outdated"
npm outdated --json > /tmp/npm-outdated.json 2>/dev/null || true
echo "::endgroup::"

# --- Analyze core packages ---
# Use node to parse JSON and compare major versions
node -e "
const fs = require('fs');
const path = require('path');

// Read npm outdated output
let outdated = {};
try {
  outdated = JSON.parse(fs.readFileSync('/tmp/npm-outdated.json', 'utf8'));
} catch (e) {
  // Empty or invalid JSON means nothing is outdated
}

// Read package.json to know which packages are installed
let pkgJson = {};
try {
  pkgJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
} catch (e) {
  console.error('Could not read package.json');
  process.exit(1);
}
const allDeps = {
  ...(pkgJson.dependencies || {}),
  ...(pkgJson.devDependencies || {}),
};

// Core packages from env (newline-separated)
const corePackages = process.env.POLICY_CORE_PACKAGES
  .split('\n')
  .map(p => p.trim())
  .filter(Boolean);

const results = [];
let warningCount = 0;

for (const pkg of corePackages) {
  const info = outdated[pkg];

  if (!info) {
    // Not in npm outdated output â€” either up to date or not installed
    if (allDeps[pkg]) {
      results.push({ pkg, current: 'latest', latest: 'latest', behind: 0, status: 'current' });
    } else {
      results.push({ pkg, current: '-', latest: '-', behind: 0, status: 'not-installed' });
    }
    continue;
  }

  const current = info.current || 'unknown';
  const latest = info.latest || 'unknown';

  // Extract major versions
  const currentMajor = parseInt(current.split('.')[0], 10);
  const latestMajor = parseInt(latest.split('.')[0], 10);

  if (isNaN(currentMajor) || isNaN(latestMajor)) {
    results.push({ pkg, current, latest, behind: 0, status: 'unknown' });
    continue;
  }

  const behind = latestMajor - currentMajor;

  if (behind > 0) {
    results.push({ pkg, current, latest, behind, status: 'outdated' });
    warningCount++;
  } else {
    results.push({ pkg, current, latest, behind: 0, status: 'current' });
  }
}

// --- Build markdown ---
let md = '## ðŸ“¦ Dependency Check\n\n';

const outdatedResults = results.filter(r => r.status === 'outdated');
const currentResults = results.filter(r => r.status === 'current');
const otherResults = results.filter(r => !['outdated', 'current'].includes(r.status));

if (outdatedResults.length > 0) {
  md += '| Package | Current | Latest | Majors Behind |\n';
  md += '|---------|---------|--------|:-------------:|\n';
  for (const r of outdatedResults) {
    const emoji = r.behind >= 2 ? 'ðŸ”´' : 'ðŸŸ¡';
    md += '| ' + r.pkg + ' | ' + r.current + ' | ' + r.latest + ' | ' + emoji + ' ' + r.behind + ' |\n';
  }
  md += '\n';
}

if (currentResults.length > 0) {
  md += '<details><summary>âœ… Up to date (' + currentResults.length + ' packages)</summary>\n\n';
  for (const r of currentResults) {
    md += '- ' + r.pkg;
    if (r.current !== 'latest') {
      md += ' (' + r.current + ')';
    }
    md += '\n';
  }
  md += '\n</details>\n\n';
}

if (otherResults.length > 0) {
  for (const r of otherResults) {
    md += '> âš ï¸ **' + r.pkg + '**: ' + (r.status === 'not-installed' ? 'Not found in package.json' : 'Could not determine version') + '\n';
  }
  md += '\n';
}

if (warningCount > 0) {
  md += '> **' + warningCount + ' of ' + corePackages.length + '** core packages have major updates available.\n\n';
} else {
  md += '> All **' + corePackages.length + '** core packages are on the latest major version. âœ…\n\n';
}

md += '---\n';
md += '*Generated by [semantic-release-action](https://github.com/Rajlus/semantic-release-action)*\n';

fs.writeFileSync('/tmp/dependency-check.md', md);

// Set output
const status = warningCount > 0 ? 'warn' : 'pass';
fs.appendFileSync(process.env.GITHUB_OUTPUT, 'status=' + status + '\n');

console.log('Dependency check: ' + status + ' (' + warningCount + ' major updates found)');
" || {
  echo "::error::dependency-check.sh: node script failed"
  echo "status=pass" >> "$GITHUB_OUTPUT"
  exit 1
}

# --- Post PR comment ---
if [ -n "${PR_NUMBER:-}" ]; then
  bash "$SCRIPT_DIR/update-pr-comment.sh" \
    "DEPENDENCY_CHECK" \
    "/tmp/dependency-check.md" \
    "dependency check"
fi
