name: 'Semantic Release'
description: 'Reusable composite action for semantic-release with changelog generation, PR previews, dependency checks, and security audits'

inputs:
  mode:
    description: 'Operation mode: "release", "pr-changelog", "dependency-check", or "security-audit"'
    required: true
    default: 'release'
  github-token:
    description: 'GitHub token with contents:write and pull-requests:write permissions'
    required: true
  node-version:
    description: 'Node.js version to use'
    required: false
    default: '20'
  extra-plugins:
    description: 'Space-separated list of additional semantic-release plugins to install'
    required: false
    default: ''
  dry-run:
    description: 'Run in dry-run mode (no release created, only in release mode)'
    required: false
    default: 'false'
  core-packages:
    description: 'Comma-separated list of core packages to check for major updates. Overridden by .dependency-policy.yml if present.'
    required: false
    default: ''
  audit-fail-on:
    description: 'Minimum severity that fails the pipeline: critical, high, moderate, low. Overridden by .dependency-policy.yml if present.'
    required: false
    default: 'high'
  audit-production-only:
    description: 'Only audit production dependencies (true/false). Overridden by .dependency-policy.yml if present.'
    required: false
    default: 'false'

outputs:
  new-release-published:
    description: 'Whether a new release was published'
    value: ${{ steps.release.outputs.new-release-published }}
  new-release-version:
    description: 'The new release version'
    value: ${{ steps.release.outputs.new-release-version }}
  dependency-check-status:
    description: 'Result of dependency check: "pass" or "warn"'
    value: ${{ steps.dependency-check.outputs.status }}
  security-audit-status:
    description: 'Result of security audit: "pass" or "fail"'
    value: ${{ steps.security-audit.outputs.status }}

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    # ---- RELEASE / PR-CHANGELOG MODES ----

    - name: Install semantic-release and plugins
      if: inputs.mode == 'release' || inputs.mode == 'pr-changelog'
      shell: bash
      run: |
        npm install --no-save \
          semantic-release@24 \
          @semantic-release/changelog@6 \
          @semantic-release/git@10 \
          conventional-changelog-conventionalcommits@8 \
          ${{ inputs.extra-plugins }}

    - name: Generate default config if none exists
      if: inputs.mode == 'release' || inputs.mode == 'pr-changelog'
      shell: bash
      run: |
        if [ ! -f .releaserc.yml ] && [ ! -f .releaserc.yaml ] && [ ! -f .releaserc.json ] && [ ! -f .releaserc.js ] && [ ! -f .releaserc.cjs ] && [ ! -f release.config.js ] && [ ! -f release.config.cjs ]; then
          cat > .releaserc.yml << 'RCEOF'
        branches:
          - main
        plugins:
          - - "@semantic-release/commit-analyzer"
            - preset: conventionalcommits
          - - "@semantic-release/release-notes-generator"
            - preset: conventionalcommits
          - - "@semantic-release/changelog"
            - changelogFile: CHANGELOG.md
          - - "@semantic-release/git"
            - assets:
                - CHANGELOG.md
                - package.json
                - package-lock.json
              message: "chore(release): ${nextRelease.version} [skip ci]"
          - "@semantic-release/github"
        RCEOF
          echo "::notice::Created default .releaserc.yml (no config found in repo)"
        else
          echo "::notice::Using existing release config from repository"
        fi

    - name: Run semantic-release
      if: inputs.mode == 'release'
      id: release
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        ARGS=""
        if [ "${{ inputs.dry-run }}" = "true" ]; then
          ARGS="--dry-run"
        fi

        npx semantic-release $ARGS 2>&1 | tee /tmp/semantic-release-output.log

        # Parse output for version
        VERSION=$(grep -oP 'Published release \K[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?' /tmp/semantic-release-output.log || echo "")
        if [ -n "$VERSION" ]; then
          echo "new-release-published=true" >> "$GITHUB_OUTPUT"
          echo "new-release-version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "::notice::Released version $VERSION"
        else
          echo "new-release-published=false" >> "$GITHUB_OUTPUT"
          echo "new-release-version=" >> "$GITHUB_OUTPUT"
          echo "::notice::No new release published"
        fi

    - name: Generate PR changelog via local repo
      if: inputs.mode == 'pr-changelog'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        LOCAL_REPO="/tmp/semantic-release-local-repo"

        echo "::group::Setting up local bare git repo for changelog generation"

        # Fetch full history (checkout might be shallow)
        git fetch --unshallow 2>/dev/null || true
        git fetch origin "+refs/tags/*:refs/tags/*" 2>/dev/null || true

        # Create local bare repo and push all branches + tags to it
        git init --bare "$LOCAL_REPO"
        git remote add local "$LOCAL_REPO" 2>/dev/null || git remote set-url local "$LOCAL_REPO"
        git branch -rd origin/HEAD 2>/dev/null || true
        git push local --tags "refs/remotes/origin/*:refs/heads/*" 2>/dev/null || true

        # Determine the actual branch name (detached HEAD in PR checkouts gives "HEAD")
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$CURRENT_BRANCH" = "HEAD" ]; then
          # In PR context, GITHUB_HEAD_REF contains the source branch name
          CURRENT_BRANCH="${GITHUB_HEAD_REF:-$(git log -1 --format=%D | grep -oP 'origin/\K[^,]+' | head -1)}"
        fi
        echo "::notice::Using branch: $CURRENT_BRANCH"

        # Push the current PR branch (it might not be in remotes)
        git push local "HEAD:refs/heads/$CURRENT_BRANCH" 2>/dev/null || true

        # Set HEAD in bare repo so git fetch doesn't fail with "couldn't find remote ref HEAD"
        git -C "$LOCAL_REPO" symbolic-ref HEAD "refs/heads/$CURRENT_BRANCH"

        echo "::endgroup::"

        # Hide pre-release tags so changelog shows all changes since last stable release
        echo "::group::Hiding pre-release tags"
        git tag -l | { grep -E '.*-(dev|alpha|beta|rc)\.' || true; } | while read tag; do
          git tag -d "$tag" 2>/dev/null || true
          git -C "$LOCAL_REPO" tag -d "$tag" 2>/dev/null || true
        done
        echo "::endgroup::"

        # Override branches config to treat current branch as a stable release branch
        # This ensures we get a proper version (1.2.3) not a pre-release (1.2.3-branch.1)
        echo "::group::Configuring release for PR branch"

        # Backup original config
        RELEASERC=""
        for f in .releaserc.yml .releaserc.yaml .releaserc.json .releaserc.js release.config.js release.config.cjs; do
          if [ -f "$f" ]; then
            RELEASERC="$f"
            cp "$f" "/tmp/releaserc-backup"
            break
          fi
        done

        if [ -n "$RELEASERC" ]; then
          node "${{ github.action_path }}/scripts/modify-releaserc.js" "$RELEASERC" "$CURRENT_BRANCH" 2>/dev/null || echo "::warning::Could not modify release config, using as-is"
        fi

        echo "::endgroup::"

        # Configure git user (required by @semantic-release/git)
        git config --global user.email "semantic-release-bot@users.noreply.github.com"
        git config --global user.name "semantic-release-bot"

        # Checkout the actual branch so semantic-release detects the correct branch name
        # (GitHub PRs use detached HEAD on refs/pull/N/merge which semantic-release rejects)
        git checkout -B "$CURRENT_BRANCH" HEAD

        # Run semantic-release against local repo (not dry-run! but targeting local bare repo)
        # Override GITHUB_REF so env-ci reports the correct branch instead of refs/pull/N/merge
        echo "::group::Running semantic-release against local repo"
        GITHUB_REF="refs/heads/$CURRENT_BRANCH" GITHUB_EVENT_NAME="push" \
          npx semantic-release --no-ci --repository-url "file://$LOCAL_REPO" 2>&1 | tee /tmp/semantic-release-output.log || true
        echo "::endgroup::"

        # Restore original config
        if [ -n "$RELEASERC" ] && [ -f "/tmp/releaserc-backup" ]; then
          cp "/tmp/releaserc-backup" "$RELEASERC"
        fi

        # Read generated CHANGELOG.md
        NOTES=""
        if [ -f CHANGELOG.md ]; then
          # Extract only the first version section (from first ## X.Y.Z to the next ## X.Y.Z or end)
          NOTES=$(awk '
            /^#+ \[?[0-9]+\.[0-9]+\.[0-9]+/ {
              if (found) exit
              found = 1
            }
            found { print }
          ' CHANGELOG.md)

          # Replace local repo URLs with actual GitHub URLs
          REPO_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"
          NOTES=$(echo "$NOTES" | sed "s|https*:/tmp/semantic-release-local-repo|${REPO_URL}|g")
          NOTES=$(echo "$NOTES" | sed "s|file:///tmp/semantic-release-local-repo|${REPO_URL}|g")

          # Clean up: restore original CHANGELOG.md (or remove if it didn't exist)
          git checkout -- CHANGELOG.md 2>/dev/null || rm -f CHANGELOG.md
        fi

        # Fallback: parse dry-run output
        if [ -z "$NOTES" ]; then
          NEXT_VERSION=$(grep -oP 'next release version is \K[0-9]+\.[0-9]+\.[0-9]+' /tmp/semantic-release-output.log 2>/dev/null || echo "")
          if [ -n "$NEXT_VERSION" ]; then
            NOTES=$(printf '**Next version: %s**\n\n*Full changelog will be generated on merge.*' "$NEXT_VERSION")
          else
            NOTES="No releasable changes detected based on conventional commits."
          fi
        fi

        echo "$NOTES" > /tmp/pr-changelog.md

        # Cleanup
        rm -rf "$LOCAL_REPO"
        git remote remove local 2>/dev/null || true

        echo "::notice::Generated PR changelog preview"

    - name: Update PR body with changelog
      if: inputs.mode == 'pr-changelog'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        bash "${{ github.action_path }}/scripts/update-pr-changelog.sh"

    # ---- DEPENDENCY CHECK MODE ----

    - name: Install project dependencies (dependency-check)
      if: inputs.mode == 'dependency-check'
      shell: bash
      run: |
        npm ci --ignore-scripts 2>/dev/null || npm install --ignore-scripts 2>/dev/null || true

    - name: Run dependency check
      if: inputs.mode == 'dependency-check'
      id: dependency-check
      shell: bash
      env:
        INPUT_CORE_PACKAGES: ${{ inputs.core-packages }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        bash "${{ github.action_path }}/scripts/dependency-check.sh"

    # ---- SECURITY AUDIT MODE ----

    - name: Install project dependencies (security-audit)
      if: inputs.mode == 'security-audit'
      shell: bash
      run: |
        npm ci --ignore-scripts 2>/dev/null || npm install --ignore-scripts 2>/dev/null || true

    - name: Run security audit
      if: inputs.mode == 'security-audit'
      id: security-audit
      shell: bash
      env:
        INPUT_AUDIT_FAIL_ON: ${{ inputs.audit-fail-on }}
        INPUT_AUDIT_PRODUCTION_ONLY: ${{ inputs.audit-production-only }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GH_TOKEN: ${{ inputs.github-token }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        bash "${{ github.action_path }}/scripts/security-audit.sh"
